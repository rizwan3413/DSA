



Embedded Development :
======================
C
C++
Linux
Shell scripting




Multithreading : It is a technique of handling multiple threads simultaneously
================
- Thread is a path that is followed during program execution 
- Majority of programs written today are single thread.

Process - A program which is being executed is a Process ( Collection of Threads)
Thread - Its a path followed during program execution or a light weight process 

Concurrent vs Paralell execution :
==================================

Concurrent Execution - If a processor can switch execution resources between threads in a multithreaded process on a single processor ,then  it is termed as concurrent execution 

Parallel Execution - 


Concurrency - When two tasks start,run and complete in different time periods
              Ex: Multitasking in single core-machine 

Parallelism - When two tasks starts at same time interval 
              Ex : Multi core processor 
			  

Tasks are executed based on Tasks Sceduling mechanisms:
=======================================================
1) First come first serve
2) Round robin
3) Priority Scheduling

Prioity inversion is a problem in Priority Sceduling

In general High Priority tasks are executed first 

If a low priority task is using shared resource or a critical section,High priority task must wait until low priority tasks has completed of CS.

If high priority task has a critical dealine it has to meet then lock out time for shared resources has to be calculated.

Priority Inversion occurs when a medium priority task pre-empts a low priority task which is using a shared resource common to high priority task 
Where H is kept to wait from a medium priority task hence inverting the priority 

This can be resolved by using Priority Inheritance


Mutex  :
========
Mutex is a lockable object that is designed to signal when critical Section of code exclusive access preventing other threads with the same protection from executing concurrently
 

#include <iostream>       // std::cout
#include <thread>         // std::thread
#include <mutex>          // std::mutex

std::mutex mtx;           // mutex for critical section

void print_block (int n, char c) {
  // critical section (exclusive access to std::cout signaled by locking mtx):
  mtx.lock();
  for (int i=0; i<n; ++i) { std::cout << c; }
  std::cout << '\n';
  mtx.unlock();
}

int main ()
{
  std::thread th1 (print_block,50,'*');
  std::thread th2 (print_block,50,'$');

  th1.join();
  th2.join();

  return 0;
} 

lock function mechanism:
========================
#include <iostream>       // std::cout
#include <thread>         // std::thread
#include <mutex>          // std::mutex

std::mutex mtx;           // mutex for critical section

void print_thread_id (int id) {
  // critical section (exclusive access to std::cout signaled by locking mtx):
  mtx.lock();
  std::cout << "thread #" << id << '\n';
  mtx.unlock();
}

int main ()
{
  std::thread threads[10];
  // spawn 10 threads:
  for (int i=0; i<10; ++i)
    threads[i] = std::thread(print_thread_id,i+1);

  for (auto& th : threads) th.join();

  return 0;
}

try_lock
========
// mutex::try_lock example
#include <iostream>       // std::cout
#include <thread>         // std::thread
#include <mutex>          // std::mutex

volatile int counter (0); // non-atomic counter
std::mutex mtx;           // locks access to counter

void attempt_10_increases () {
  for (int i=0; i<10; ++i) {
    if (mtx.try_lock()) {   // only increase if currently not locked:
      ++counter;
      mtx.unlock();
    }
  }
}

int main ()
{
  std::thread threads[10];
  // spawn 10 threads:
  for (int i=0; i<10; ++i)
    threads[i] = std::thread(attempt_10_increases);

  for (auto& th : threads) th.join();
  std::cout << counter << " successful increases of the counter.\n";

  return 0;
}

Lock_gaurd
==========

#include <iostream>       // std::cout
#include <thread>         // std::thread
#include <mutex>          // std::mutex, std::lock_guard
#include <stdexcept>      // std::logic_error

std::mutex mtx;

void print_even (int x) {
  if (x%2==0) 
  std::cout << x << " is even\n";
  else throw (std::logic_error("not even"));
}

void print_thread_id (int id) {
  try {
    // using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:
    std::lock_guard<std::mutex> lck (mtx);
    print_even(id);
  }
  catch (std::logic_error&) {
    std::cout << "[exception caught]\n";
  }
}

int main ()
{
  std::thread threads[10];
  // spawn 10 threads:
  for (int i=0; i<10; ++i)
    threads[i] = std::thread(print_thread_id,i+1);

  for (auto& th : threads) th.join();

  return 0;
}

unique_lock
============
#include <iostream>       // std::cout
#include <thread>         // std::thread
#include <mutex>          // std::mutex, std::unique_lock

std::mutex mtx;           // mutex for critical section

void print_block (int n, char c) {
  // critical section (exclusive access to std::cout signaled by lifetime of lck):
  std::unique_lock<std::mutex> lck (mtx);
  for (int i=0; i<n; ++i) { std::cout << c; }
  std::cout << '\n';
}

int main ()
{
  std::thread th1 (print_block,50,'*');
  std::thread th2 (print_block,50,'$');

  th1.join();
  th2.join();

  return 0;
}




J1939 is extended CAN protocol :
===============================
It is typically used in 

- Diesel power train applications 
- In Vehicle networks for trucks and buses
- Agriculture and forestry Machinary 
- Military vehicles 
- Fleet management Systems
- Recreational Vehilces 
- Marine Navigational Systems
- Fleet management Systems 


It was developed in 1995 with 29 bit identifier respectively 11 and 18 bit 

11 bit identifier allows 2^11 messages = 2048 different messages whereas 29 bit identifier allows 2^29 allows 536 million messages 

29 bit frame has Identifier  Extension Bit which is Low for standard frame and high for 29 bit frame 

During Bus arbitration the standard 11 bit message will have high priority than an extended 29 bit message ID 

CAN was originally designed for automobiles but the demand for microprocessors increased and high speed requirment of serial communication system 

The CAN properties can be summarized as:
􀂾 Multi-Master priority based bus access
􀂾 Non-destructive contention-based arbitration
􀂾 Multicast message transfer by message acceptance filtering
􀂾 Remote data request
􀂾 Configuration flexibility
􀂾 System-wide data consistency
􀂾 Error detection and error signaling
􀂾 Automatic retransmission of messages that lost arbitration
􀂾 Automatic retransmission of messages that were destroyed by errors
􀂾 Distinction between temporary errors and permanent failures of nodes
􀂾 Autonomous deactivation of defective nodes

CAN alone is not suitable for machine automation, since its communication between devices is limited to only 8
bytes per message. 

As a consequence,higher layer protocols such as CANopen for machine control, 
DeviceNet for factory automation and J1939 for vehicles were designed to provide a real networking technology that support messages of unlimited length and allow a master/slave configuration.

CAN communication bypasses the connection betweeen communication and data link layer 

J1939 with CAN :
================

- Maximum reliability
- Excellant error detection and fault confinement 
- Collision free bus arbitration 
 
 
 Demerits :
 =========
 It is troubling to learn that the SAE J1939 standard has no problem with compromising the CAN standard. The Network Management (SAE J1939/81), for instance, allows scenarios where two CAN nodes with the
same message ID can access the bus. 

The result of such a situation is unpredictable. In addition, the SAE J1939 message format (as described
in SAE J1939/21) does not take advantage of the message filtering as provided by all CAN controllers in the industry


J1939 Features :(Message Length upto 1785 bytes)
================
Higher-Layer Protocol using CAN as the physical layer
􀂾 Shielded twisted pair wire
􀂾 Max. network length of 40 meters (~120 ft.)
􀂾 Standard baud rate of 250 kBit/sec
􀂾 Max. 30 nodes (ECUs) in a network
􀂾 Max. 253 controller applications (CA) where one ECU can manage several CAs
􀂾 Peer-to-peer and broadcast communication
􀂾 Support for message length up to 1785 bytes
􀂾 Definition of Parameter Groups (Predefined vehicle parameters)
􀂾 Network Management (includes address claiming procedure).

29 bit breakdown 

3 Priority 

18 PGN bit - 1 Bit reserved 1 Bit Data Page 8 bit PDU format 8 bit PDU specific 

8 source address





Pattern Problems:
=================
#include<iostream>
using namespace std;

**************
*************
***********
**********
*********
*******
******
****
***
**
*
* 
**
***
****
*****
******
*******
********
*********
**********
***********
               
void printPattern1(int n);            
void printPattern(int n) 
{ 
    // Variable initialization 
    int line_no = 1; // Line count 
  
    // Loop to print desired pattern 
    int curr_star = n+1; 
    
    repeat:
    
    for (line_no = 1; line_no <= n+1;line_no++ ) 
    { 
        // If current star count is less than 
        // current line number 
        
        if (curr_star > line_no) 
        { 
           cout << "* "; 
           continue; 
        } 
  
        // Else time to print a new line 
        if (curr_star == line_no) 
        { 
           cout << "\n";
           curr_star --; 
           if(curr_star!=1)
           goto repeat;
        }
        
    } 
    printPattern1(n);
} 

void printPattern1(int n) 
{ 
    // Variable initialization 
    int line_no = 1; // Line count 
  
    // Loop to print desired pattern 
    int curr_star = 0; 
    for (int line_no = 1; line_no <= n; ) 
    { 
        // If current star count is less than 
        // current line number 
        if (curr_star < line_no) 
        { 
           cout << "* "; 
           curr_star++; 
           continue; 
        } 
  
        // Else time to print a new line 
        if (curr_star == line_no) 
        { 
           cout << "\n"; 
           line_no++; 
           curr_star = 0; 
        } 
    } 
    
} 

int main()
{
    int n;
    
    cout << "Enter the number of stars to be printed untill" << endl;
    
    cin >> n;
    
    printPattern(n);
    
    
    return 0;
}



Heart pattern problem:
==============
//Program to print heart pattern
#include<stdio.h>
#include<conio.h>
#include<iostream>
using namespace std;

int main()
{

 int n,i,j;
 cout<<"Enter limit for pattern : ";
 cin>>n;
 if(n%2==0)
  n++;

 for(i=0;i<n;i++)
 {
  for(j=0;j<n;j++)
  {
   if(i==0&&(j>=n/5&&j<=n/2-n/5)||i==0&&(j>=n/2+n/5&&j<=(n-1)-n/5))
    cout<<"* ";
   else if(i>0&&i<=n/5&&(j==n/5-i||j==n/2+n/5-i||j==n/2-n/5+i||j==(n-1)-n/5+i))
    cout<<"* ";
   else if((i>n/5&&i<=n/2)&&(j==0||j==n-1))
    cout<<"* ";
   else if(i>n/2&&(j==i-n/2||j==(n-1)-(i-n/2)))
    cout<<"* ";
   else
    cout<<"  ";
  }
  cout<<"\n";
 }
 getch();
}

memset() function:
==================
void *memset(void *ptr, int x, size_t n);

// C program to demonstrate working of memset() 
#include <stdio.h> 
#include <string.h> 
  
int main() 
{ 
    char str[50] = "GeeksForGeeks is for programming geeks."; 
    printf("\nBefore memset(): %s\n", str); 
  
    // Fill 8 characters starting from str[13] with '.' 
    memset(str + 13, '.', 8*sizeof(char)); 
  
    printf("After memset():  %s", str); 
    return 0; 
} 

memcpy function :
================

void * memcpy(void *to, const void *from, size_t numBytes);//Copies the contents of one string to another 

#include <stdio.h> 
#include <string.h> 
  
int main () 
{ 
  char str1[] = "Geeks";   
  char str2[] = "Quiz";   
  
  puts("str1 before memcpy "); 
  puts(str1); 
  
  /* Copies contents of str2 to sr1 */
  memcpy (str1, str2, sizeof(str2)); 
  
  puts("\nstr1 after memcpy "); 
  puts(str1); 
  
  return 0; 
} 

O/p:
===
str1 before memcpy 
Geeks

str1 after memcpy 
Quiz

Program 1: For Printing N largest Elements (A function which takes an array and returns N largest Elements present in an array)
===============================================================================================================================
#include<iostream>
#include<cstring>
using namespace std;

void swap(int *a,int *b)
{
    int temp = *a;
    *a =*b;
    *b = temp;
}

int* Nlargest(int arr[],int size,int n)
{
    for(int i=0;i<size-1;i++)
    {
        for(int j=0;j<size-1;j++)
        {
            if(arr[j]>arr[j+1])
            swap(&arr[j],&arr[j+1]);
        }
    }
    return arr;
}

int  main()
{
  int arr[] = {7,8,9,1,2,3,5,15};
  
  int size = sizeof(arr)/sizeof(arr[0]);
  int x =5;
  for(int i =0;i<size;i++)
  {
      cout << arr[i] << " ";

  }
  
  cout << endl;
  
  Nlargest(arr,size,x);
  //7 8 9 1 2 3 5 15
  
  //1 2 3 5 7 8 9 15
  
  for(int i=size-1;i>size-1-x;i--)
  {
      cout << arr[i] << " ";

  }
  
  return 0;
  
}

Program 2: Program to reverse a String without using Library function ( Write a Function which takes a String and Reverse the String)
======================================================================================================================================

#include<iostream>
#include<cstring>
using namespace std;

char * ReverseString(char *pString)
{
    if(NULL==pString)
    return NULL;
    
    char *pStart = pString;
    
    char *pEnd = pStart+strlen(pString)-1;
    
    while(pStart < pEnd)
    {
        char temp = *pStart;
        *pStart   = *pEnd;
        *pEnd     =  temp;
        
        pStart++;
        pEnd--;
    }
    return pString;
}

int  main()
{
  char str[50] = "GUBED";
  
  cout << str << endl;
  
  cout << ReverseString(str)/*Debug*/ << endl;
  
  return 0;
  
}

Program 3: Program to check if a String is palindrome or not
=============================================================  

#include<iostream>
#include<cstring>
using namespace std;

char * ReverseString(char *pString)
{
    if(NULL==pString)
    return NULL;
    
    char *ptr = (char*)malloc(strlen(pString)+1);
    
    strcpy(ptr,pString);
    
    char *pStart = ptr;
    
    char *pEnd = pStart+strlen(ptr)-1;
    
    while(pStart < pEnd)
    {
        char temp = *pStart;
        *pStart   = *pEnd;
        *pEnd     =  temp;
        
        pStart++;
        pEnd--;
    }
    return ptr;
}

int  main()
{
  char str[50] = "MADAM";
  
  cout << str << endl;
  
  char *str1 = ReverseString(str);
  
  if(strcmp(str,str1)==0)
  {
    cout << "The Given string is a Palindrome String" << endl;
  }
  
  else
  {
    cout << "The Given string is not a Palindrome String" << endl;
  }
  
  free(str1);
  
  return 0;
  
}

Program 4: Roots of a quadratic Equation:
=========================================
#include <iostream>
#include<iomanip>
#include<cmath>
using namespace std;

int main() 
{
    double a,b,c,disc,root1,root2,real,imag;
    
    cout << "Enter the coeficients for a,b,c" << endl;
    
    cin>>a >> b >> c ;
    
    cout << std::setprecision(3) << a << b <<c << endl;
    
    disc = b*b -4*a*c;
    
    cout << disc << endl;
    
    if(disc>0)
    {
        root1 = (-b+sqrt(disc))/2*a;
        root2 = (-b-sqrt(disc))/2*a;
        
        cout << "Root 1 is : \n" << root1 << endl;
        cout << "Root 2 is : \n" << root2 << endl;
    }
  
  if(disc==0)
    {
        root1 = (-b/2*a);
        root2 = (-b/2*a);
        
        cout << "Root 1 is : \n" << root1 << endl;
        cout << "Root 2 is : \n" << root2 << endl;
    }
      
   if(disc < 0)  
    {
        real = (-b/2*a);
        imag = (sqrt(-disc)/2*a);
        
        cout << "Root 1 is : \n" << real<<""<<"+" <<"i"<<imag << endl;
        cout << "Root 2 is : \n" << real<<""<<"-" <<"i"<<imag << endl;
    }
    
    return 0;
}

Program 5 :Leap Year
=====================

#include <iostream>
using namespace std;

int main() 
{
    int num;
    
    cout <<" Enter the number" << endl;
    
    cin>>num;
    
    if(num % 4 == 0)
    {
        cout << " Entered Year is a Leap year" << endl;
    }
     
    else if(num % 100 == 0)
    {
        cout << " Entered Year is a Leap year" << endl;
    }
    
    else if(num % 400 == 0)
    {
        cout << " Entered Year is a Leap year" << endl;
    }
    
    else
    cout << " Entered Year is not a Leap year" << endl;
    
    return 0;
}

Program 6: Fibbonaci Series (With and without Recursion)
========================================================

#include <iostream>
using namespace std;

int main() 
{
    int num,res;
    
    int a=0;
    
    int b =1;
    
    cout <<" Enter the number of terms" << endl;
    
    cin>>num;
    
    for(int i =1;i<=num;i++)
    {
        cout << a << " ";
        
        res = a+b;
        a = b;
        b = res;
    }
    
    return 0;
}

Program 7 : GCD of two numbers
===============================
#include <iostream>
using namespace std;


int GCD(int n1,int n2)
{
    int gcd;
    
     for(int i=1;i<=n1&&i<=n2;i++)
    {
        if(n1 % i == 0 && n2 % i == 0)
        {
             gcd = i;
        }
    }
    return gcd;
}

int GCD1(int n1,int n2)
{
    while(n1!=n2)
    {
        if(n1 > n2)
        {
            n1 -=n2;
           
        }
        
        else
        n2 -=n1;
    }
    return n1;
}

int GCD2(int n1,int n2)
{
    n1 =(n1>0)? n1 :-n1;
    n2 =(n2>0)? n2 :-n2;
    
    while(n1!=n2)
    {
        if(n1 > n2)
        {
            n1 -=n2;
           
        }
        
        else
        n2 -=n1;
    }
    return n1;
}

int main() 
{
    
    int n1,n2;
    
    cout << "Enter the numbers" << endl;
    
    cin>>n1>>n2;
    
    cout << "GCD of n1 and n2 is :" << GCD2(n1,n2) << endl;
    
    return 0;
}

Program 8 : LCM from GCD :
==========================
#include <iostream>
using namespace std;


int GCD(int n1,int n2)
{
    int gcd;
    
     for(int i=1;i<=n1&&i<=n2;i++)
    {
        if(n1 % i == 0 && n2 % i == 0)
        {
             gcd = i;
        }
    }
    return gcd;
}

int GCD1(int n1,int n2)
{
    while(n1!=n2)
    {
        if(n1 > n2)
        {
            n1 -=n2;
           
        }
        
        else
        n2 -=n1;
    }
    return n1;
}

int GCD2(int n1,int n2)
{
    n1 =(n1>0)? n1 :-n1;
    n2 =(n2>0)? n2 :-n2;
    
    while(n1!=n2)
    {
        if(n1 > n2)
        {
            n1 -=n2;
           
        }
        
        else
        n2 -=n1;
    }
    return n1;
}

int main() 
{
    
    int n1,n2;
    
    cout << "Enter the numbers" << endl;
    
    cin>>n1>>n2;
    
    //cout << "GCD of n1 and n2 is :" << GCD2(n1,n2) << endl;
    
    int LCM = n1*n2/GCD2(n1,n2);
    
    cout << "LCM of n1 and n2 is :" << LCM << endl;
    
    return 0;
}

Program 9 : checking Armstrong for an nth digit number 
======================================================

#include <math.h>
#include <stdio.h>
#include<iostream>
using namespace std;

int main() {
    
    int num, originalNum, remainder, n = 0;
    int result = 0.0;
    cout<<"Enter an integer: ";
    
    cin>>num;
    
    
    originalNum = num;
    
    while (originalNum != 0) {
        originalNum /= 10;
        ++n;
    }
    
    originalNum = num;
    
    while (originalNum != 0) {
        remainder = originalNum % 10;
        result += pow(remainder, n);
        originalNum /= 10;
    }
    
    if (result == num)
        printf("%d is an Armstrong number.", num);
    else
        printf("%d is not an Armstrong number.", num);
    return 0;
} 

Program 10: Prime numbers between two intervals:
================================================
#include <iostream>
using namespace std;

bool checkPrimeNumber(int n);

int main()
{
    int n1, n2, i;
   
    bool flag;
    
    cout<<"Enter two positive integers: ";
    
    cin>> n1 >> n2;
    
    cout << "Prime numbers between n1 and n2 are : " << endl;
    
    for (i = n1 + 1; i < n2; i++) 
    {
        // flag will be equal to false if i is prime
        
        flag = checkPrimeNumber(i);
        
        if (flag == false)
        
            cout << i << " ";
    }
    
    return 0;
}
// user-defined function to check prime number
bool checkPrimeNumber(int n) 
{
    int j;
    
    bool flag = false;
    
    for (j = 2; j < n; j++)
    {
        if (n % j == 0) 
        {
            flag = true;
            break;
        }
    }
    return flag;
}

Program 11 : BInary to Dec and Dec to Bi conversion:
====================================================

#include<iostream>
#include <math.h>
using namespace std;

int Bitodec(long long n)
{
    int dec=0;
    int i=0;
    int r;
    
    while(n!=0)
    {
        r = n % 10;
        n /= 10;
        dec += r*pow(2,i);
        ++i;
    }
}

long long DectoBi(int n)
{
    long long bin = 0;
    
    int i =1;
    
    int r;
    
    while(n!=0)
    {
        r = n % 2;
        n/=2;
        bin+= r*i;
        i*=10;
    }
    return bin;
}

int main() 
{
    long long n;
    
    cout << "Enter the Binary number " << endl;
    
    cin>>n;
    
    cout<< "The Decimal Number is :" << Bitodec(n)<< endl;

    cout<< "The Binary Number is :" << DectoBi(Bitodec(n)) << endl;
    return 0;
}

Program 12 : To overload << and >> operator :
==============================================
#include<iostream>
using namespace std;


class Complex
{
    private:
    
    float real;
    float imag;
    
    public:
    
    
    Complex(float _real=0,float _imag=0):real(_real),imag(_imag){}
    
    friend ostream & operator << (ostream &out,const Complex &obj);
    friend istream & operator >> (istream &in,Complex &obj);
};

ostream & operator << (ostream &out,const Complex &obj)
{
    out << obj.real;
    
    out << "+i" << obj.imag << endl;
    
    return out;
}

istream & operator >> (istream &in,Complex &obj)
{
    cout << " Enter the real part : ";
    in >> obj.real;
    
    cout << " Enter the imaginary part : ";
    in >> obj.imag;
    
    return in;
}


int main()
{
    Complex obj;
    
    cin >> obj;
    
    cout << "The complex number is :" << endl;
    
    cout << obj;
    
    return 0;
}

Friend function :
=================
Points to remember is 

friend function is not a class member it is just a friend i.e it can acces private data so we cannot call it with object 

#include <iostream>
using namespace std;

class Wife;

class Husband
{
    private:
    
    char name[10];
    int salary;
    
    public:
    
    Husband()    
    {
        cout<<"Enter Name"<<endl;
        cin>>name;
        cout<<"Enter the Salary"<<endl;
        cin>>salary;
    }
   
    friend void get_data(Husband &obj);
    
    friend int totalsalary(Husband h1,Wife w1);
    
};

class Wife
{
    private:
    
    char name[10];
    int salary;
    
    public:
    
    Wife()
    {
        cout<<"Enter Name"<<endl;
        cin>>name;
        cout<<"Enter the Salary"<<endl;
        cin>>salary;
    }
    
    friend void get_data(Wife &obj);
 
    
    friend int totalsalary(Husband h1,Wife w1);
};

void get_data(Husband &obj)
{

    cout<<" Name is"<< obj.name<<endl;
    cout<<"The Salary is"<< obj.salary<<endl;
        
}

void get_data(Wife &obj)
{

    cout<<"Name is"<< obj.name <<endl;
    cout<<"The Salary is"<< obj.salary <<endl;
        
}
    
int totalsalary(Husband h1,Wife w1)
{
    
     return h1.salary + w1.salary;
}

int main()
{
  Husband a1;
  Wife a2;
  
  get_data(a1);
  get_data(a2);
  
   cout<<"TotalSalary "<< totalsalary(a1,a2) <<endl;
   return 0;
}

Friend Class :
==============
#include <iostream>
using namespace std;
class Girl;

class Boy
{
    private:
    
    int income1;
    int income2;
    
    public:
    
	Boy()
	{ 
		cout<<"Enter income1"<<endl;
        cin>>income1;
        cout<<"Enter income2"<<endl;
        cin>>income2;
      
    }
    void get_data()
    {
        cout<<"Salary from first source is"<<income1<<endl;
        
       cout<<"Salary from second source is"<<income2<<endl;        
    }
    
friend class Girl;

};


class Girl

{
    public:
    
	Girl(){}
    
	Girl(Boy &b)
    {
       cout<<"Girl class printing "<<endl;
        
		b.income1= b.income1+10000;
		b.income2= b.income2+2000;
		
		cout << b.income1 << endl;
		cout<<  b.income2 << endl;
    }

};

int main()

{
    Boy a1;
    a1.get_data();
    
	cout<<"After friend changes"<<endl;
	
	Girl g1(a1);
	
    a1.get_data();
	
    return 0;

}


Shallow Copy:
=========
#include<iostream> 
#include<cstring> 
using namespace std; 
  
class String 
{ 
private: 
    char *s; 
    int size; 
public: 
    String(const char *str = NULL); // constructor 
   // ~String() { delete [] s;  }// destructor 
    void print() { cout << s << endl; } 
    void change(const char *);  // Function to change 
}; 
  
String::String(const char *str) 
{ 
    size = strlen(str); 
    s = new char[size+1]; 
    strcpy(s, str); 
} 
  
void String::change(const char *str) 
{ 
    delete [] s; 
    size = strlen(str); 
    s = new char[size+1]; 
    strcpy(s, str); 
} 
  
int main() 
{ 
    String str1("GeeksQuiz"); 
    String str2 = str1; 
  
    str1.print(); // what is printed ? 
    str2.print(); 
  
    str2.change("GeeksforGeeks"); 
  
    str1.print(); // what is printed now ? 
    str2.print(); 
    return 0;

}

Deep copy:
=============

#include<iostream>
#include<string.h>
using namespace std;

class String
{
    private:
    
    char *s;
    int size;
    
    public:
    
    String(const char *q);
    ~String(){ delete[] s; }
    String(const String &old_str);
    
    void print()
    {
        cout << s << endl;
    }
    
    void change(const char*);
};

String :: String(const char *str)
{
    size = strlen(str);
    
    s = new char[size+1];
    
    strcpy(s,str);   
}

String :: String(const String &old_str)
{
    size = old_str.size;
    
    s = new char[size+1];
    
    strcpy(s,old_str.s);
    
}


void String :: change( const char *str)
{
    delete [] s;
    size = strlen(str);
    s = new char[size+1];
    strcpy(s,str);
}

int main()
{
    String str1("GeeksQuiz"); 
    String str2(str1); 
  
    str1.print(); // what is printed ? 
    str2.print(); 
  
    str2.change("GeeksforGeeks"); 
  
    str1.print(); // what is printed now ? 
    str2.print(); 
    return 0;

}


Questions to discuss :


i) printf("%d",8); 
ii) printf("%d",090); 
iii) printf("%d",00200); 
iv) printf("%d",0007000);  





Strings can be treated as character pointer or character arrays
================================================================

char str[4] = "GFG";

char str[4] = {'G','F','G',\0};


1)String using character pointers:
================================

When string value is directly assigned to the pointer, in most of the compilers, its stored in a read-only block(generally in data Segment) that is shared among functions


char * str = "GFG";

In the above line “GfG” is stored in a shared read-only location, but pointer str is stored in a read-write memory. 

You can change str to point something else but cannot change value at present str.

So this kind of string should only be used when we don’t want to modify string at a later stage in the program.


 #include<iostream>
 using namespace std;
 
 int main()
 {
 char *str = "GEEKS";
 
 cout << "Size of the String before : " << str << endl;
 
 int size = 4;
 
 *(str+0) = 'G';  
 *(str+1) = 'f';   
 *(str+2) = 'G';   
 *(str+3) = '\0'; 
 
 cout << "Size of the String after : " << str << endl;
 
 return 0;
 
 }

o/p:
===

Segmentation Fault as the String is stored in Read-Only memory and trying to modify/access the memory which is not accessible will lead to segmentation fault

There are two ways to get rid of the problem we are facing above 

Solution 1 : Store the String in Stack
Solution 2 : Store the String in Heap

Solution 1 :
============

#include<iostream>
using namespace std;
 
 int main()
 {
 char str[] = "GEEKS";
 
 cout << "Size of the String before : " << str << endl;
 int size = 4;
 

  str[0] = 'G';  
  str[1] = 'f';   
  str[2] = 'G';   
  str[3] = '\0'; 
 
 cout << "Size of the String after : " << str << endl;
 
 return 0;
 
 }

O/p :
=====

Size of the string before : GEEKS
Size of the string after : GFG

Solution 2 :
============

2) Dynamically allocated in heap segment :
 ==========================================
 #include<iostream>
 using namespace std;
 
 int main()
 {
 char *str = "GEEKS";
 
 cout << "Size of the String before : " << str << endl;
 int size = 4;
 
 str = (char *)malloc(sizeof(char)*4);
 
 *(str+0) = 'G';  
 *(str+1) = 'f';   
 *(str+2) = 'G';   
 *(str+3) = '\0'; 
 
 cout << "Size of the String after : " << str << endl;
 
 return 0;
 
 }
 
 
 Another example to illustrate the accesibility of two strings while returning from a function 
 
 1) Created in Read only Segment 
 2) Another created on Stack
 3) Another created on Heap
 
 1) Created in Read only Segment 
 =================================
 
 #include<iostream>
 using namespace std;
 
 char * getString()
 {
	char *str = "GEEKS";

    return str;
 
 }
 
 int main()
 {
 
	cout << getString() << endl;
	return 0;
 }
 
 
 O/p : GEEKS
 
 2) Created on Heap 
 ==================
 
 
 #include<iostream>
 using namespace std;
 
 char * getString()
 {
	char *str = nullptr;
	
    str = (char *)malloc(sizeof(char)*4);
 
    *(str+0) = 'G';  
    *(str+1) = 'f';   
    *(str+2) = 'G';   
    *(str+3) = '\0'; 

    return str;
 
 }
 
 int main()
 {
 
	cout << getString() << endl;
	return 0;
 }
 
 O/p : GFG;
 
 3) Created on Stack;
 ======================
 
  #include<iostream>
 using namespace std;
 
 char * getString()
 {
	char str[] = "GFG";
	
    return str;
 
 }
 
 int main()
 {
 
	cout << getString() << endl;
	return 0;
 }
 
 When we return a string which is locally created it returns a Garbage value 
 
 
 
 
